<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- 
      This meta tag is crucial for a full-screen mobile experience.
      It sets the width to the device's width, an initial scale of 1,
      and prevents users from zooming or scaling, which is ideal for a paint app.
    -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Toddler Finger Paint</title>
    <!-- Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --toolbar-transition-duration: 0.3s;
        }

        /* Custom styles for the app */
        body, html {
            /* Prevent scrolling and pull-to-refresh on mobile */
            overscroll-behavior: none;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            height: 100%;
            margin: 0;
            padding: 0;
            position: fixed;
            width: 100%;
        }

        #appContainer {
            /* Use dynamic viewport height for mobile browsers */
            height: 100vh;
            height: 100dvh; /* Newer browsers - accounts for mobile browser chrome */
        }

        canvas {
            /* Ensure canvas is flush against the edges */
            display: block;
            /* This is the magic for multi-touch. 
              It disables browser gestures like panning, zooming, and scrolling
              that would normally interfere with drawing.
            */
            touch-action: none; 
        }

        /* Style for the active/selected button */
        .brush-button.active {
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.5);
            transform: scale(1.1);
        }
        
        /* Toolbar collapse/expand styles */
        #toolbarContent {
            max-height: 500px;
            overflow: hidden;
            transition: max-height var(--toolbar-transition-duration) ease-in-out, 
                        opacity var(--toolbar-transition-duration) ease-in-out;
            opacity: 1;
        }
        
        #toolbarContent.collapsed {
            max-height: 0;
            opacity: 0;
        }
        
        #toggleButton {
            transition: transform var(--toolbar-transition-duration) ease-in-out;
        }
        
        #toggleButton.collapsed {
            transform: rotate(180deg);
        }
    </style>
</head>
<body class="bg-gray-200">

    <!-- Main container: flex, full-screen, column layout -->
    <div id="appContainer" class="flex flex-col h-screen w-screen">
        
        <!-- Canvas: takes up all available space (flex-grow) -->
        <canvas id="paintCanvas" class="flex-grow bg-white cursor-crosshair"></canvas>

        <!-- Toolbar: at the bottom, wraps content, centered -->
        <div id="toolbar" class="bg-gray-100 shadow-inner flex-shrink-0">
            <!-- Toggle button at the top -->
            <div class="flex justify-center py-2 border-b border-gray-300">
                <button id="toggleButton" class="w-12 h-8 bg-gray-300 hover:bg-gray-400 rounded-lg shadow-md flex items-center justify-center transition-all active:scale-95">
                    <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                        <path d="M5 7.5L10 12.5L15 7.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
            </div>
            
            <!-- Toolbar content that can be collapsed -->
            <div id="toolbarContent" class="p-4">
                <div class="flex flex-wrap justify-center items-center gap-4 max-w-4xl mx-auto">
                    <!-- Color Brushes -->
                    <button data-color="#E53E3E" class="brush-button w-14 h-14 sm:w-16 sm:h-16 rounded-full bg-red-600 border-4 border-white shadow-md transition-transform"></button>
                    <button data-color="#3B82F6" class="brush-button w-14 h-14 sm:w-16 sm:h-16 rounded-full bg-blue-500 border-4 border-white shadow-md transition-transform"></button>
                    <button data-color="#10B981" class="brush-button w-14 h-14 sm:w-16 sm:h-16 rounded-full bg-green-500 border-4 border-white shadow-md transition-transform"></button>
                    <button data-color="#F59E0B" class="brush-button w-14 h-14 sm:w-16 sm:h-16 rounded-full bg-yellow-500 border-4 border-white shadow-md transition-transform"></button>
                    <button data-color="#000000" class="brush-button w-14 h-14 sm:w-16 sm:h-16 rounded-full bg-black border-4 border-white shadow-md transition-transform"></button>

                    <!-- Separator -->
                    <div class="w-px h-16 bg-gray-300 hidden sm:block"></div>

                    <!-- Size Brushes -->
                    <button data-size="10" class="brush-button w-14 h-14 sm:w-16 sm:h-16 rounded-full bg-gray-300 border-4 border-white shadow-md flex items-center justify-center transition-transform">
                        <div class="w-3 h-3 rounded-full bg-gray-700"></div>
                    </button>
                    <button data-size="30" class="brush-button w-14 h-14 sm:w-16 sm:h-16 rounded-full bg-gray-300 border-4 border-white shadow-md flex items-center justify-center transition-transform">
                        <div class="w-6 h-6 rounded-full bg-gray-700"></div>
                    </button>
                    <button data-size="60" class="brush-button w-14 h-14 sm:w-16 sm:h-16 rounded-full bg-gray-300 border-4 border-white shadow-md flex items-center justify-center transition-transform">
                        <div class="w-10 h-10 rounded-full bg-gray-700"></div>
                    </button>
                    
                    <!-- Separator -->
                    <div class="w-px h-16 bg-gray-300 hidden sm:block"></div>

                    <!-- Undo Button -->
                    <button id="undoButton" class="w-14 h-14 sm:w-16 sm:h-16 bg-blue-500 text-white rounded-lg shadow-md transition-transform active:scale-95 flex items-center justify-center">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
                            <path d="M9 14L4 9L9 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M20 20V13C20 11.9391 19.5786 10.9217 18.8284 10.1716C18.0783 9.42143 17.0609 9 16 9H4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </button>

                    <!-- Clear Button -->
                    <button id="clearButton" class="w-14 h-14 sm:w-16 sm:h-16 bg-red-500 text-white rounded-lg shadow-md transition-transform active:scale-95 flex items-center justify-center">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
                            <path d="M18 6L6 18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M6 6L18 18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        window.addEventListener('load', () => {
            // ========================================
            // DOM ELEMENTS
            // ========================================
            const canvas = document.getElementById('paintCanvas');
            const toolbar = document.getElementById('toolbar');
            const ctx = canvas.getContext('2d');
            const appContainer = document.getElementById('appContainer');

            // ========================================
            // STATE VARIABLES
            // ========================================
            let mouseDrawing = false;
            let brushColor = '#E53E3E';
            let brushSize = 30;
            
            // Map to store active touches and their properties
            // Key: touch.identifier, Value: { x, y, color, size }
            const activeTouches = new Map();
            
            // History for undo functionality
            const canvasHistory = [];
            const maxHistorySize = 20;

            // ========================================
            // CANVAS MANAGEMENT
            // ========================================
            
            function saveCanvasState() {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                canvasHistory.push(imageData);
                
                if (canvasHistory.length > maxHistorySize) {
                    canvasHistory.shift();
                }
                
                updateUndoButton();
            }
            
            function updateUndoButton() {
                const undoButton = document.getElementById('undoButton');
                if (canvasHistory.length > 0) {
                    undoButton.disabled = false;
                    undoButton.classList.remove('opacity-50', 'cursor-not-allowed');
                } else {
                    undoButton.disabled = true;
                    undoButton.classList.add('opacity-50', 'cursor-not-allowed');
                }
            }

            function setAppHeight() {
                const vh = window.innerHeight;
                appContainer.style.height = vh + 'px';
            }

            function initializeCanvas() {
                const toolbarHeight = toolbar.offsetHeight;
                canvas.width = appContainer.clientWidth;
                canvas.height = appContainer.clientHeight - toolbarHeight;
                
                ctx.fillStyle = "white";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                saveCanvasState();
            }
            
            function resizeCanvas() {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const toolbarHeight = toolbar.offsetHeight;
                
                canvas.width = appContainer.clientWidth;
                canvas.height = appContainer.clientHeight - toolbarHeight;
                
                ctx.putImageData(imageData, 0, 0);
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
            }

            // ========================================
            // COORDINATE HELPERS
            // ========================================
            
            function getMouseCoords(e) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }

            function getTouchCoords(touch) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: touch.clientX - rect.left,
                    y: touch.clientY - rect.top
                };
            }

            // ========================================
            // MOUSE DRAWING HANDLERS
            // ========================================
            
            function startMouseDraw(e) {
                mouseDrawing = true;
                const { x, y } = getMouseCoords(e);
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineWidth = brushSize;
                ctx.strokeStyle = brushColor;
            }

            function mouseDraw(e) {
                if (!mouseDrawing) return;
                const { x, y } = getMouseCoords(e);
                ctx.lineTo(x, y);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(x, y);
            }

            function stopMouseDraw() {
                if (mouseDrawing) {
                    mouseDrawing = false;
                    ctx.closePath();
                    saveCanvasState();
                }
            }

            // ========================================
            // MULTI-TOUCH DRAWING HANDLERS
            // ========================================
            
            function handleTouchStart(e) {
                e.preventDefault();
                const touches = e.changedTouches;

                for (let i = 0; i < touches.length; i++) {
                    const touch = touches[i];
                    const { x, y } = getTouchCoords(touch);
                    
                    activeTouches.set(touch.identifier, {
                        x: x,
                        y: y,
                        color: brushColor,
                        size: brushSize
                    });

                    ctx.beginPath();
                    ctx.lineWidth = brushSize;
                    ctx.strokeStyle = brushColor;
                    ctx.moveTo(x, y);
                }
            }

            function handleTouchMove(e) {
                e.preventDefault();
                const touches = e.changedTouches;

                for (let i = 0; i < touches.length; i++) {
                    const touch = touches[i];
                    const touchData = activeTouches.get(touch.identifier);

                    if (touchData) {
                        const { x, y } = getTouchCoords(touch);

                        ctx.beginPath();
                        ctx.moveTo(touchData.x, touchData.y);
                        ctx.lineWidth = touchData.size;
                        ctx.strokeStyle = touchData.color;
                        ctx.lineTo(x, y);
                        ctx.stroke();
                        
                        touchData.x = x;
                        touchData.y = y;
                    }
                }
            }

            function handleTouchEnd(e) {
                e.preventDefault();
                const touches = e.changedTouches;

                for (let i = 0; i < touches.length; i++) {
                    const touch = touches[i];
                    const touchData = activeTouches.get(touch.identifier);

                    if (touchData) {
                        ctx.closePath();
                        activeTouches.delete(touch.identifier);
                    }
                }
                
                if (activeTouches.size === 0) {
                    saveCanvasState();
                }
            }

            // ========================================
            // EVENT LISTENERS
            // ========================================
            
            // Canvas: Mouse events
            canvas.addEventListener('mousedown', startMouseDraw);
            canvas.addEventListener('mousemove', mouseDraw);
            canvas.addEventListener('mouseup', stopMouseDraw);
            canvas.addEventListener('mouseout', stopMouseDraw);

            // Canvas: Touch events
            canvas.addEventListener('touchstart', handleTouchStart);
            canvas.addEventListener('touchmove', handleTouchMove);
            canvas.addEventListener('touchend', handleTouchEnd);
            canvas.addEventListener('touchcancel', handleTouchEnd);

            // Window: Resize events
            window.addEventListener('resize', () => {
                setAppHeight();
                resizeCanvas();
            });

            // ========================================
            // TOOLBAR CONTROLS
            // ========================================
            
            // Brush buttons (color and size)
            const buttons = document.querySelectorAll('.brush-button');
            buttons.forEach(button => {
                button.addEventListener('click', () => {
                    if (button.dataset.color) {
                        document.querySelectorAll('[data-color]').forEach(btn => btn.classList.remove('active'));
                        brushColor = button.dataset.color;
                    }
                    if (button.dataset.size) {
                        document.querySelectorAll('[data-size]').forEach(btn => btn.classList.remove('active'));
                        brushSize = parseInt(button.dataset.size, 10);
                    }
                    button.classList.add('active');
                });
            });

            // Undo button
            document.getElementById('undoButton').addEventListener('click', () => {
                if (canvasHistory.length > 0) {
                    canvasHistory.pop();
                    
                    if (canvasHistory.length > 0) {
                        const previousState = canvasHistory[canvasHistory.length - 1];
                        ctx.putImageData(previousState, 0, 0);
                    } else {
                        ctx.fillStyle = "white";
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        saveCanvasState();
                    }
                    
                    updateUndoButton();
                }
            });

            // Clear button
            document.getElementById('clearButton').addEventListener('click', () => {
                canvasHistory.length = 0;
                initializeCanvas();
                activeTouches.clear();
            });
            
            // Toolbar collapse/expand toggle
            const toggleButton = document.getElementById('toggleButton');
            const toolbarContent = document.getElementById('toolbarContent');
            const toolbarTransitionDuration = parseFloat(
                getComputedStyle(document.documentElement)
                    .getPropertyValue('--toolbar-transition-duration')
            ) * 1000;
            let isToolbarExpanded = true;
            
            toggleButton.addEventListener('click', () => {
                isToolbarExpanded = !isToolbarExpanded;
                
                if (isToolbarExpanded) {
                    toolbarContent.classList.remove('collapsed');
                    toggleButton.classList.remove('collapsed');
                } else {
                    toolbarContent.classList.add('collapsed');
                    toggleButton.classList.add('collapsed');
                }
                
                setTimeout(() => {
                    resizeCanvas();
                }, toolbarTransitionDuration);
            });

            // ========================================
            // INITIALIZATION
            // ========================================
            
            setAppHeight();
            initializeCanvas();
            
            // Set default active buttons
            document.querySelector('[data-color="#E53E3E"]').classList.add('active');
            document.querySelector('[data-size="30"]').classList.add('active');
        });
    </script>
</body>
</html>

